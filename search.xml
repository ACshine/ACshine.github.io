<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>dpdream</title>
    <url>/2022/02/15/dpdream/</url>
    <content><![CDATA[<h1 id="蒙德里安的梦想-超级详细，从0开始，思路自然，一遍就会！"><a href="#蒙德里安的梦想-超级详细，从0开始，思路自然，一遍就会！" class="headerlink" title="蒙德里安的梦想 (超级详细，从0开始，思路自然，一遍就会！)"></a>蒙德里安的梦想 (超级详细，从0开始，思路自然，一遍就会！)</h1><p><img src="https://cdn.acwing.com/media/article/image/2022/02/15/152778_4029f3468e-b8f1cbace1c9693c5ca86991af57db5.jpg" alt="b8f1cbace1c9693c5ca86991af57db5.jpg"> </p>
<h3 id="算法标签：状态压缩dp"><a href="#算法标签：状态压缩dp" class="headerlink" title="算法标签：状态压缩dp"></a>算法标签：状态压缩dp</h3><h3 id="题目大意：求把-N×M的棋盘分割成若干个1×2-的的小长方形，有多少种方案。"><a href="#题目大意：求把-N×M的棋盘分割成若干个1×2-的的小长方形，有多少种方案。" class="headerlink" title="题目大意：求把 N×M的棋盘分割成若干个1×2 的的小长方形，有多少种方案。"></a>题目大意：求把 N×M的棋盘分割成若干个1×2 的的小长方形，有多少种方案。</h3><h4 id="1：思路分析："><a href="#1：思路分析：" class="headerlink" title="1：思路分析："></a>1：思路分析：</h4><p>  首先，注意到，我们直接考虑如何切割整个棋盘为若干个1x2的长方形是比较困难的，因此，我们可以把整个棋盘划分为若干个1x1的小格子，那么，问题就转化为了用1x2的小长方形去将整个棋盘填充满，总共有多少种方案。此外，注意到，当我们将所有横向的小长方形都已经摆放(填充)完成后，所有纵向的小长方形的摆放方式也就唯一确定了，那么，总的方案数就等于摆完所有横向长方形的方案数。所以，我们只用考虑如何枚举横向长方形的摆放即可</p>
<h4 id="模型："><a href="#模型：" class="headerlink" title="模型："></a>模型：</h4><p>这个问题属于状态压缩dp问题的第一大类：基于连通性的dp，也可以叫做棋盘式dp。<strong>我们首先考虑如何定义(设计)状态</strong>，<strong>也就是如何进行状态表示。</strong> 我们按列来枚举横向小长方形的摆放情况。f为dp数组。若当前我们需要摆放的列是第i 列，那么第i列在摆放的时候只和第i-1列有关(因为只有i-1列的小长方形可能伸到第i列，影响第i 列的摆放)。因此，我们设f[i][j]表示：前i-1列已经摆放完毕(不能再改了)，当前要对第i列进行横向小长方形的摆放，且前一列伸出一个小方格是j 的情况下的方案数。如下图所示：</p>
<p><img src="https://cdn.acwing.com/media/article/image/2022/02/15/152778_23efd7448e-%E6%97%A0%E6%A0%87%E9%A2%98.png" alt="无标题.png"> </p>
<p>j是一个n位的二进制数，上图对应的j为01，代表第i-1列第0行伸出了一个小放个(所以j的第0位为1)。那么，这个状态表示的集合就是：</p>
<p><strong>所有前i-1列已经摆放完毕且第i-1列伸出小方格的状态为j的情况下的摆放方案</strong></p>
<p>f[i][j]记录的是集合中的方案总数(根据题目所求来确定)</p>
<p>   <strong>接下来考虑如何进行状态计算(转移)<strong>，所谓状态计算，就是对集合进行划分，而划分的依据就是</strong>“最后一个不同点”</strong>。根据我们上面f[i][j]的定义，第i-1列横向小长方形的摆放方案是确定的(因为二进制数j代表了其摆放的情况)，所以，最后一个不同点就是第i-2列的摆放情况。因此，我们将依据第i-2列的摆放情况对f[i][j]所表示的大集合进行划分，将它划分成1&lt;&lt;n个子集。但是，这些子集不一定都可以转移过来，因此，我们需要判断哪些子集所对应的状态才可以转移到我们当前的状态。为了方便之后的表示，我们设a为第i-1列的“摆放情况”，b为第i-2列的”摆放情况”。那么，<strong>合法的状态需要满足以下两个条件</strong>：<strong>1：</strong>a&amp;b&#x3D;&#x3D;0,即二者的二进制不能有某一位同时为1(意思是第i-2列和第i-1列不能在同一行同时摆放上横向的小长方形(同时伸出小格子)，因为这样，第i-2列伸出的小方格就会”阻碍”到第i-1列的摆放，是不合法的)</p>
<p><strong>2:</strong> 由于第i-1列横向的格子已经摆放完毕，那么其纵向格子的摆放方式也已经确定，所以，我们摆完横向的小长方形后，剩下连续的空格子的数量不能是奇数，否则就不能通过摆放纵向小长方形将整个棋盘填满了。所以，我们需要算出每个状态下连续0的个数。这个条件的判断可以通过”预处理完成”。</p>
<p>另外，我们可以预处理出所有合法(能够进行状态转移的状态),方便后续状态的计算。</p>
<p>这样，f[i][j]就等于所有能转移到它的状态所对应的方案数的总和。</p>
<p>我们最终的答案就是:f[m][0]。注意，下标从0开始，所以，它代表所有前m–1列(也就是整个棋盘)已经摆完，并且伸出格子的情况为0(没有伸出棋盘，是合法的)的方案总数。并且，dp数组的初始化为：f[0][0]&#x3D;1(因为摆第0列时不存在前一列会伸出来，也就表示当前列没有横着摆的小长方形，所以只有都竖着摆放这一种情况)</p>
<h4 id="c-代码"><a href="#c-代码" class="headerlink" title="c++代码"></a><em>c++代码</em></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=12,M=1&lt;&lt;N;</span><br><span class="line">typedef long long LL;</span><br><span class="line">int n,m,st[M];//st==1表示当前状态是合法的</span><br><span class="line">LL f[N][M];//极限状态下可能会爆int</span><br><span class="line">vector&lt;int&gt;truestate[M];//二维数组，truestate[i]中存储所有可以转移到状态i的状态，方便通过循环递推计算出所有状态的值</span><br><span class="line">//vector&lt;vector&lt;int&gt;&gt;truestate(M);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;m,n||m) //逗号表达式的值为逗号之后的值</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;i&lt;1&lt;&lt;n;i++)//枚举所有状态，判断其是否有连续奇数个0</span><br><span class="line">        &#123;</span><br><span class="line">            st[i]=1;</span><br><span class="line">            int cnt=0;//连续奇数0的个数</span><br><span class="line">            for(int j=0;j&lt;n;j++)</span><br><span class="line">                if(i&gt;&gt;j&amp;1)//i的第j位是1,前一段连续的0终止了</span><br><span class="line">                &#123;</span><br><span class="line">                   if(cnt&amp;1)//cnt为奇数</span><br><span class="line">                    &#123;</span><br><span class="line">                        st[i]=0;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cnt=0; //继续统计下一段连续0的个数，要将上一段的数量清零(实际上不清0也可以AC，因为加一个偶数不会影响奇偶性(奇数会break))</span><br><span class="line">                &#125;else</span><br><span class="line">                    cnt++;</span><br><span class="line">            if(cnt&amp;1)//判断最后一段连续0的个数的奇偶性</span><br><span class="line">                st[i]=0;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;1&lt;&lt;n;i++)//计算出所有的truestate 这里i枚举的是状态定义中对应的第i-1列的情况，j枚举的是第i-2列对应的情况</span><br><span class="line">        &#123;</span><br><span class="line">            truestate[i].clear();</span><br><span class="line">            for(int j=0;j&lt;1&lt;&lt;n;j++)</span><br><span class="line">                if(!(i&amp;j)&amp;&amp;st[i|j])//只要二者有一位为1，连续0就会被隔断,所以，第状态定义中第i-1列实际的状态是i|j</span><br><span class="line">                    truestate[i].push_back(j);</span><br><span class="line">        &#125;</span><br><span class="line">        memset(f,0,sizeof(f));</span><br><span class="line">        f[0][0]=1;</span><br><span class="line">        for(int i=1;i&lt;=m;i++)//枚举所有列</span><br><span class="line">            for(int j=0;j&lt;1&lt;&lt;n;j++)//枚举所有状态</span><br><span class="line">                for(auto &amp;k:truestate[j])//遍历所有可以转移到j的状态</span><br><span class="line">                    f[i][j]+=f[i-1][k];//状态计算(转移)</span><br><span class="line">        cout&lt;&lt;f[m][0]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>##时间复杂度分析：dp的时间复杂度 &#x3D;状态数量× 状态转移(计算)</p>
<p>状态表示 f[i][j] 第一维i可取11，第二维j（二进制数）可取2的11次方,根据乘法原理，可计算出状态数量<br>状态转移 也是2的11次方(每个状态最多可划分成这么多个子集)<br>所以总的时间复杂度约等于&#x3D;4e7</p>
<p>有不对的地方欢迎指正，有不懂的地方欢迎大家提问！<br>题解的博客地址:<a href="https://acshine.github.io/">https://acshine.github.io/</a></p>
]]></content>
  </entry>
  <entry>
    <title>shine-first-blog</title>
    <url>/2022/02/14/shine-first-blog/</url>
    <content><![CDATA[<h1 id="第一条blog"><a href="#第一条blog" class="headerlink" title="第一条blog"></a><strong>第一条blog</strong></h1><p>  大家好，我是 ACshine ,这是我的第一条blog,今后，我将会更新一些算法题的题解，以及对一些自己学过知识的总结与反思。</p>
<p><strong>博主QQ：965188927</strong></p>
<span id="more"></span>

<p>希望自己可以坚持下去，并且水平越来越高)</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/02/14/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
