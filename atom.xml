<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://acshine.github.io/atom.xml" rel="self"/>
  
  <link href="https://acshine.github.io/"/>
  <updated>2022-02-17T04:13:43.997Z</updated>
  <id>https://acshine.github.io/</id>
  
  <author>
    <name>ACshine</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>奶牛选美题解</title>
    <link href="https://acshine.github.io/2022/02/17/%E5%A5%B6%E7%89%9B%E9%80%89%E7%BE%8E%E9%A2%98%E8%A7%A3/"/>
    <id>https://acshine.github.io/2022/02/17/%E5%A5%B6%E7%89%9B%E9%80%89%E7%BE%8E%E9%A2%98%E8%A7%A3/</id>
    <published>2022-02-17T04:07:13.000Z</published>
    <updated>2022-02-17T04:13:43.997Z</updated>
    
    <content type="html"><![CDATA[<h1 id="奶牛选美-双端队列解法及代码"><a href="#奶牛选美-双端队列解法及代码" class="headerlink" title="奶牛选美(双端队列解法及代码)"></a>奶牛选美(双端队列解法及代码)</h1><h3 id="算法标签：双端队列bfs"><a href="#算法标签：双端队列bfs" class="headerlink" title="算法标签：双端队列bfs"></a>算法标签：双端队列bfs</h3><h3 id="题目大意：求为了将两个由’X’组成的连通块连通起来，最少需要将多少个’-’变为’X’。"><a href="#题目大意：求为了将两个由’X’组成的连通块连通起来，最少需要将多少个’-’变为’X’。" class="headerlink" title="题目大意：求为了将两个由’X’组成的连通块连通起来，最少需要将多少个’.’变为’X’。"></a>题目大意：求为了将两个由’X’组成的连通块连通起来，最少需要将多少个’.’变为’X’。</h3><span id="more"></span><h4 id="1：思路分析：-（后面有具体解释"><a href="#1：思路分析：-（后面有具体解释" class="headerlink" title="1：思路分析： （后面有具体解释)"></a>1：思路分析： （后面有具体解释)</h4><p>  首先，我们可以任取一个值为’X’的点作为bfs的起点(，然后，在bfs的过程中，我们建立双端队列q，首先把距离数组初始化为充分大的常数INF,然后把起点的距离设为0，并把起点加入队列，当队列不空时，我们取出队头元素，如果队头元素对应的值为’X’，且其到起点的距离不为0，那么直接返回其距离即可，这就是最终答案。否则，通过st数组判断这个点到起点的最短距离是否已经算过了，如果没算过，那么和Dijkstra算法类似，我们将其对应的st数组设置为1，代表它的最短距离已经确定，然后用这个点来更新它周围四个点的距离。</p><p><strong>如果周围的点是’.’那么权重w为1，否则为0</strong>    如果可以更新，那么将新扩展到的点的距离更新。<strong>并且，如果w为0，那么将新扩展到的点加入队头，否则，加入队尾</strong></p><h4 id="模型及具体解释"><a href="#模型及具体解释" class="headerlink" title="模型及具体解释"></a>模型及具体解释</h4><p>这道题目的模型属于双端队列模型。之所以将权重为0的点加入队头，而将权重为1的点加入队尾的原因是这样操作之后，队列中元素距离起点的距离仍然是单调递增的，所以，这样求出来的距离才是最短距离(与堆优化的Dijkstra类似)。</p><p>此外，之所以可以随便选择一个’X’作为起点，也是由于我们将’X’的权重设为了0，所以不会影响最终的答案。其实，这道题就等价于求从起点到终点的最小步数，这不过，题目中的步数实际上是指将’X’变为’.’的操作。而当我们扩展到另一个’X’ 且其距离不为0时，这个X肯定是和起点的‘X’不属于同一连通块(否则其最短距离就应该是0)，而通过bfs，求出的是最短距离，自然，我们此时返回的就是所求的答案了。</p><h4 id="c-代码"><a href="#c-代码" class="headerlink" title="c++代码"></a><em>c++代码</em></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=55;</span><br><span class="line">typedef pair&lt;int,int&gt;PII; </span><br><span class="line">int n,m,st[N][N],d[N][N];</span><br><span class="line">char g[N][N];</span><br><span class="line">int dx[4]=&#123;-1,0,1,0&#125;,dy[4]=&#123;0,1,0,-1&#125;;</span><br><span class="line">int bfs(int sx,int sy)</span><br><span class="line">&#123;</span><br><span class="line">    deque&lt;PII&gt;q;</span><br><span class="line">    memset(d,0x3f,sizeof d);</span><br><span class="line">    q.push_back(&#123;sx,sy&#125;);</span><br><span class="line">    d[sx][sy]=0;</span><br><span class="line">    while(q.size())</span><br><span class="line">    &#123;</span><br><span class="line">        auto t=q.front();</span><br><span class="line">        q.pop_front();</span><br><span class="line">        int a=t.first,b=t.second;</span><br><span class="line">        if(g[a][b]==&#x27;X&#x27;&amp;&amp;d[a][b]) return d[a][b];</span><br><span class="line">        if(st[a][b]) continue;</span><br><span class="line">        st[a][b]=1;</span><br><span class="line">        for(int i=0;i&lt;4;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int nx=a+dx[i],ny=b+dy[i];</span><br><span class="line">            if(nx&lt;0||nx&gt;=n||ny&lt;0||ny&gt;=m) continue;</span><br><span class="line">            int w=g[nx][ny]==&#x27;.&#x27;;</span><br><span class="line">            if(d[nx][ny]&gt;d[a][b]+w)</span><br><span class="line">            &#123;</span><br><span class="line">                d[nx][ny]=d[a][b]+w;</span><br><span class="line">                if(!w) q.push_front(&#123;nx,ny&#125;);</span><br><span class="line">                else q.push_back(&#123;nx,ny&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 66666;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123; </span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    int t1,t2;</span><br><span class="line">    for(int i=0;i&lt;n;i++)  cin&gt;&gt;g[i];</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">        for(int j=0;j&lt;m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(g[i][j]==&#x27;X&#x27;)</span><br><span class="line">                &#123;</span><br><span class="line">                    t1=i,t2=j;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;bfs(t1,t2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##时间复杂度分析：通过双端队列的优化可以达到线性的时间复杂度。</p><p>有不对的地方欢迎指正，有不懂的地方欢迎大家提问！<br>题解的博客地址:<a href="https://acshine.github.io/">https://acshine.github.io/</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;奶牛选美-双端队列解法及代码&quot;&gt;&lt;a href=&quot;#奶牛选美-双端队列解法及代码&quot; class=&quot;headerlink&quot; title=&quot;奶牛选美(双端队列解法及代码)&quot;&gt;&lt;/a&gt;奶牛选美(双端队列解法及代码)&lt;/h1&gt;&lt;h3 id=&quot;算法标签：双端队列bfs&quot;&gt;&lt;a href=&quot;#算法标签：双端队列bfs&quot; class=&quot;headerlink&quot; title=&quot;算法标签：双端队列bfs&quot;&gt;&lt;/a&gt;算法标签：双端队列bfs&lt;/h3&gt;&lt;h3 id=&quot;题目大意：求为了将两个由’X’组成的连通块连通起来，最少需要将多少个’-’变为’X’。&quot;&gt;&lt;a href=&quot;#题目大意：求为了将两个由’X’组成的连通块连通起来，最少需要将多少个’-’变为’X’。&quot; class=&quot;headerlink&quot; title=&quot;题目大意：求为了将两个由’X’组成的连通块连通起来，最少需要将多少个’.’变为’X’。&quot;&gt;&lt;/a&gt;题目大意：求为了将两个由’X’组成的连通块连通起来，最少需要将多少个’.’变为’X’。&lt;/h3&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>蒙德里安的梦想 题解</title>
    <link href="https://acshine.github.io/2022/02/15/dpdream/"/>
    <id>https://acshine.github.io/2022/02/15/dpdream/</id>
    <published>2022-02-15T13:31:54.000Z</published>
    <updated>2022-02-15T13:38:16.430Z</updated>
    
    <content type="html"><![CDATA[<h1 id="蒙德里安的梦想-超级详细，从0开始，思路自然，一遍就会！"><a href="#蒙德里安的梦想-超级详细，从0开始，思路自然，一遍就会！" class="headerlink" title="蒙德里安的梦想 (超级详细，从0开始，思路自然，一遍就会！)"></a>蒙德里安的梦想 (超级详细，从0开始，思路自然，一遍就会！)</h1><p><img src="https://cdn.acwing.com/media/article/image/2022/02/15/152778_4029f3468e-b8f1cbace1c9693c5ca86991af57db5.jpg" alt="b8f1cbace1c9693c5ca86991af57db5.jpg"> </p><span id="more"></span><h3 id="算法标签：状态压缩dp"><a href="#算法标签：状态压缩dp" class="headerlink" title="算法标签：状态压缩dp"></a>算法标签：状态压缩dp</h3><h3 id="题目大意：求把-N×M的棋盘分割成若干个1×2-的的小长方形，有多少种方案。"><a href="#题目大意：求把-N×M的棋盘分割成若干个1×2-的的小长方形，有多少种方案。" class="headerlink" title="题目大意：求把 N×M的棋盘分割成若干个1×2 的的小长方形，有多少种方案。"></a>题目大意：求把 N×M的棋盘分割成若干个1×2 的的小长方形，有多少种方案。</h3><h4 id="1：思路分析："><a href="#1：思路分析：" class="headerlink" title="1：思路分析："></a>1：思路分析：</h4><p>  首先，注意到，我们直接考虑如何切割整个棋盘为若干个1x2的长方形是比较困难的，因此，我们可以把整个棋盘划分为若干个1x1的小格子，那么，问题就转化为了用1x2的小长方形去将整个棋盘填充满，总共有多少种方案。此外，注意到，当我们将所有横向的小长方形都已经摆放(填充)完成后，所有纵向的小长方形的摆放方式也就唯一确定了，那么，总的方案数就等于摆完所有横向长方形的方案数。所以，我们只用考虑如何枚举横向长方形的摆放即可</p><h4 id="模型："><a href="#模型：" class="headerlink" title="模型："></a>模型：</h4><p>这个问题属于状态压缩dp问题的第一大类：基于连通性的dp，也可以叫做棋盘式dp。<strong>我们首先考虑如何定义(设计)状态</strong>，<strong>也就是如何进行状态表示。</strong> 我们按列来枚举横向小长方形的摆放情况。f为dp数组。若当前我们需要摆放的列是第i 列，那么第i列在摆放的时候只和第i-1列有关(因为只有i-1列的小长方形可能伸到第i列，影响第i 列的摆放)。因此，我们设f[i][j]表示：前i-1列已经摆放完毕(不能再改了)，当前要对第i列进行横向小长方形的摆放，且前一列伸出一个小方格是j 的情况下的方案数。如下图所示：</p><p><img src="https://cdn.acwing.com/media/article/image/2022/02/15/152778_23efd7448e-%E6%97%A0%E6%A0%87%E9%A2%98.png" alt="无标题.png"> </p><p>j是一个n位的二进制数，上图对应的j为01，代表第i-1列第0行伸出了一个小放个(所以j的第0位为1)。那么，这个状态表示的集合就是：</p><p><strong>所有前i-1列已经摆放完毕且第i-1列伸出小方格的状态为j的情况下的摆放方案</strong></p><p>f[i][j]记录的是集合中的方案总数(根据题目所求来确定)</p><p>   <strong>接下来考虑如何进行状态计算(转移)<strong>，所谓状态计算，就是对集合进行划分，而划分的依据就是</strong>“最后一个不同点”</strong>。根据我们上面f[i][j]的定义，第i-1列横向小长方形的摆放方案是确定的(因为二进制数j代表了其摆放的情况)，所以，最后一个不同点就是第i-2列的摆放情况。因此，我们将依据第i-2列的摆放情况对f[i][j]所表示的大集合进行划分，将它划分成1&lt;&lt;n个子集。但是，这些子集不一定都可以转移过来，因此，我们需要判断哪些子集所对应的状态才可以转移到我们当前的状态。为了方便之后的表示，我们设a为第i-1列的“摆放情况”，b为第i-2列的”摆放情况”。那么，<strong>合法的状态需要满足以下两个条件</strong>：<strong>1：</strong>a&amp;b&#x3D;&#x3D;0,即二者的二进制不能有某一位同时为1(意思是第i-2列和第i-1列不能在同一行同时摆放上横向的小长方形(同时伸出小格子)，因为这样，第i-2列伸出的小方格就会”阻碍”到第i-1列的摆放，是不合法的)</p><p><strong>2:</strong> 由于第i-1列横向的格子已经摆放完毕，那么其纵向格子的摆放方式也已经确定，所以，我们摆完横向的小长方形后，剩下连续的空格子的数量不能是奇数，否则就不能通过摆放纵向小长方形将整个棋盘填满了。所以，我们需要算出每个状态下连续0的个数。这个条件的判断可以通过”预处理完成”。</p><p>另外，我们可以预处理出所有合法(能够进行状态转移的状态),方便后续状态的计算。</p><p>这样，f[i][j]就等于所有能转移到它的状态所对应的方案数的总和。</p><p>我们最终的答案就是:f[m][0]。注意，下标从0开始，所以，它代表所有前m–1列(也就是整个棋盘)已经摆完，并且伸出格子的情况为0(没有伸出棋盘，是合法的)的方案总数。并且，dp数组的初始化为：f[0][0]&#x3D;1(因为摆第0列时不存在前一列会伸出来，也就表示当前列没有横着摆的小长方形，所以只有都竖着摆放这一种情况)</p><h4 id="c-代码"><a href="#c-代码" class="headerlink" title="c++代码"></a><em>c++代码</em></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=12,M=1&lt;&lt;N;</span><br><span class="line">typedef long long LL;</span><br><span class="line">int n,m,st[M];//st==1表示当前状态是合法的</span><br><span class="line">LL f[N][M];//极限状态下可能会爆int</span><br><span class="line">vector&lt;int&gt;truestate[M];//二维数组，truestate[i]中存储所有可以转移到状态i的状态，方便通过循环递推计算出所有状态的值</span><br><span class="line">//vector&lt;vector&lt;int&gt;&gt;truestate(M);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while(cin&gt;&gt;n&gt;&gt;m,n||m) //逗号表达式的值为逗号之后的值</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i=0;i&lt;1&lt;&lt;n;i++)//枚举所有状态，判断其是否有连续奇数个0</span><br><span class="line">        &#123;</span><br><span class="line">            st[i]=1;</span><br><span class="line">            int cnt=0;//连续奇数0的个数</span><br><span class="line">            for(int j=0;j&lt;n;j++)</span><br><span class="line">                if(i&gt;&gt;j&amp;1)//i的第j位是1,前一段连续的0终止了</span><br><span class="line">                &#123;</span><br><span class="line">                   if(cnt&amp;1)//cnt为奇数</span><br><span class="line">                    &#123;</span><br><span class="line">                        st[i]=0;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cnt=0; //继续统计下一段连续0的个数，要将上一段的数量清零(实际上不清0也可以AC，因为加一个偶数不会影响奇偶性(奇数会break))</span><br><span class="line">                &#125;else</span><br><span class="line">                    cnt++;</span><br><span class="line">            if(cnt&amp;1)//判断最后一段连续0的个数的奇偶性</span><br><span class="line">                st[i]=0;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;1&lt;&lt;n;i++)//计算出所有的truestate 这里i枚举的是状态定义中对应的第i-1列的情况，j枚举的是第i-2列对应的情况</span><br><span class="line">        &#123;</span><br><span class="line">            truestate[i].clear();</span><br><span class="line">            for(int j=0;j&lt;1&lt;&lt;n;j++)</span><br><span class="line">                if(!(i&amp;j)&amp;&amp;st[i|j])//只要二者有一位为1，连续0就会被隔断,所以，第状态定义中第i-1列实际的状态是i|j</span><br><span class="line">                    truestate[i].push_back(j);</span><br><span class="line">        &#125;</span><br><span class="line">        memset(f,0,sizeof(f));</span><br><span class="line">        f[0][0]=1;</span><br><span class="line">        for(int i=1;i&lt;=m;i++)//枚举所有列</span><br><span class="line">            for(int j=0;j&lt;1&lt;&lt;n;j++)//枚举所有状态</span><br><span class="line">                for(auto &amp;k:truestate[j])//遍历所有可以转移到j的状态</span><br><span class="line">                    f[i][j]+=f[i-1][k];//状态计算(转移)</span><br><span class="line">        cout&lt;&lt;f[m][0]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##时间复杂度分析：dp的时间复杂度 &#x3D;状态数量× 状态转移(计算)</p><p>状态表示 f[i][j] 第一维i可取11，第二维j（二进制数）可取2的11次方,根据乘法原理，可计算出状态数量<br>状态转移 也是2的11次方(每个状态最多可划分成这么多个子集)<br>所以总的时间复杂度约等于&#x3D;4e7</p><p>有不对的地方欢迎指正，有不懂的地方欢迎大家提问！<br>题解的博客地址:<a href="https://acshine.github.io/">https://acshine.github.io/</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;蒙德里安的梦想-超级详细，从0开始，思路自然，一遍就会！&quot;&gt;&lt;a href=&quot;#蒙德里安的梦想-超级详细，从0开始，思路自然，一遍就会！&quot; class=&quot;headerlink&quot; title=&quot;蒙德里安的梦想 (超级详细，从0开始，思路自然，一遍就会！)&quot;&gt;&lt;/a&gt;蒙德里安的梦想 (超级详细，从0开始，思路自然，一遍就会！)&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.acwing.com/media/article/image/2022/02/15/152778_4029f3468e-b8f1cbace1c9693c5ca86991af57db5.jpg&quot; alt=&quot;b8f1cbace1c9693c5ca86991af57db5.jpg&quot;&gt; &lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>shine-first-blog</title>
    <link href="https://acshine.github.io/2022/02/14/shine-first-blog/"/>
    <id>https://acshine.github.io/2022/02/14/shine-first-blog/</id>
    <published>2022-02-14T12:46:37.000Z</published>
    <updated>2022-02-15T09:08:22.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一条blog"><a href="#第一条blog" class="headerlink" title="第一条blog"></a><strong>第一条blog</strong></h1><p>  大家好，我是 ACshine ,这是我的第一条blog,今后，我将会更新一些算法题的题解，以及对一些自己学过知识的总结与反思。</p><p><strong>博主QQ：965188927</strong></p><span id="more"></span><p>希望自己可以坚持下去，并且水平越来越高)</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;第一条blog&quot;&gt;&lt;a href=&quot;#第一条blog&quot; class=&quot;headerlink&quot; title=&quot;第一条blog&quot;&gt;&lt;/a&gt;&lt;strong&gt;第一条blog&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;  大家好，我是 ACshine ,这是我的第一条blog,今后，我将会更新一些算法题的题解，以及对一些自己学过知识的总结与反思。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;博主QQ：965188927&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://acshine.github.io/2022/02/14/hello-world/"/>
    <id>https://acshine.github.io/2022/02/14/hello-world/</id>
    <published>2022-02-14T12:36:33.325Z</published>
    <updated>2022-02-14T12:36:33.325Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
